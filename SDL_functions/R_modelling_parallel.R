# This R script runs mass-univariate analysis by parallely fitting
# a given model (in text strings) on multiple outcome variables (Ys) based on the same predictors (Xs), 
# and save the statistical outputs (TIDY) as well as model estimations (GLANCE) following Broom style.

# This script could be run using terminal command with 5 arguments such as
# Rscript path/to/R_modelling_parallel.R arg1 arg2 arg3 arg4 arg5
# --- arg1, full path to xfile.csv, which contains predictors (row = observation, column = variable).
# --- arg2, full path to yfile.csv, which contains outcome variables (row = observation, column = variable).
# --- arg3, full path to the output directory.
# --- arg4, model name, e.g. "model_01"
# --- arg5, texts of model formula, e.g., "lmer(Yvar ~ GROUP + AGE + SEX + (1|SITE))" or "lm(Yvar ~ GROUP + AGE + SEX)".
# An example of terminal command:
# Rscript ./SDL_functions/R_modelling_parallel.R ./Progress/Subjects.csv ./Progress/atlas_conn_SFC/static_fc/segmented/V47000_48880.csv  ./Progress/atlas_conn_SFC/static_fc/stats/V47000_48880/Mega "model_01" "lmer(Yvar ~ GROUP + AGE + SEX + (1|SITE))"

# Copyright (c) 2024 Delin Sun (ds366@duke.edu; sundelinustc@gmail.com)
# All rights reserved.
# This script is the property of Delin Sun.
# No part of this script may be reproduced in any form without the prior permission of Delin Sun.

# # for test purpose only
# xfile   <- '/tmp/isilon/morey/lab/dusom_morey/Delin/Projects/ENIGMA_PTSD-MDD/Scripts/Processes/Subjects.csv'
# # yfile   <- '/tmp/isilon/morey/lab/dusom_morey/Delin/Projects/ENIGMA_PTSD-MDD/Scripts/Processes/corrMatrix_atlas-schaefer2011Combined/segmented/V47000_48880.csv'
# yfile   <- '/tmp/isilon/morey/lab/dusom_morey/Delin/Projects/ENIGMA_PTSD-MDD/Scripts/Processes/fALFF_alff/segmented/V757435_779076.csv'
# # out_dir <- 'Processes/corrMatrix_atlas-schaefer2011Combined/stats/V47000_48880/Mega'
# out_dir <- 'Processes/fALFF_alff/stats/V757435_779076/Mega'
# model_name <- 'Model_02'
# # formula <- "lm(Yvar ~ GROUP * AGE + SEX)"
# formula <- 'lmer(Yvar ~ GROUP * AGE + SEX + (1|SITE))'

# (0) get command line arguments
args <- commandArgs(trailingOnly = TRUE)
xfile   <- args[1]
yfile   <- args[2]
out_dir <- args[3]
model_name <- args[4]
formula <- args[5]

# (1) Packages
# install pacman to load the other packages
if (!require(pacman)){install.packages('pacman', dependencies = TRUE)}
library(pacman)
# basic packages
packages <- c('data.table','foreach','doParallel','broom')
# specific packages for the given model formula
if (grepl("lmer\\(", formula)){packages <- c(packages,'lme4','lmerTest','broom.mixed')}
# load all packages of interest
do.call(p_load, as.list(packages))

# (2) Helper functions
# (2.1) function to fit the model and return the tidy and glance results
fit_model <- function(yvar, formula, dt) {
  # input
  # --- yvar, a column name in dataframe, e.g., "V123"
  # --- formula, a string of model, e.g., "lmer(Yvar ~ GROUP + AGE + SEX + (1|SITE))", 
  #              or "lm(Yvar ~ GROUP + AGE + SEX)"
  # --- dt, data table (by data.table) of independent (Xs) and dependent (Ys) variables
  # output (return a list of tidy & glance)
  # --- tidy, a data table of the model's statistical outputs
  # --- glance, a data table of model summaries

  # modify texts of the given formula
  # replace "Yvar" with yvar, which is a column name, e.g., 'V123'
  str_formula <- gsub("Yvar", yvar, formula)
  # replace the last element of the text with new ending texts
  str_formula <- sub(".$", ", data=dt)", str_formula)

  # Fit the model using the specified model function
  fit <- eval(parse(text = str_formula)) # any kind of formula, love it so much!

  # Get the tidy and glance results as data.tables
  tidy <- as.data.table(tidy(fit))
  glance <- as.data.table(glance(fit))

  # Return a list of tidy and glance
  return(list(tidy = tidy, glance = glance))
}

# (2.2) function to fit models across multiple dependent variables parallely
fit_model_parallel <- function(xdt, ydt, formula, fit_model){
  # input
  # --- xdt, data.table of independent variables (Xs)
  # --- ydt, data.table of dependent variables (Ys)
  # --- formula, a string of model, e.g., "lmer(Yvar ~ GROUP + AGE + SEX + (1|SITE))", 
  #              or "lm(Yvar ~ GROUP + AGE + SEX)"
  # --- fit_model, the pre-defined function fit_model

  # create a list where each element is a list containing a data.table of ydt column and the corresponding column name
  ydt_list <- lapply(colnames(ydt), function(y) list(data = data.table(ydt[[y]]), name = y))

  # packages for parallel processing
  if (grepl("lmer\\(", formula)) {
    # for linear mixed effects model
    packages <- c("data.table", "lme4", "lmerTest", "broom.mixed")
  } else {
    packages <- c("data.table", "broom")
  }

  # function to combine outputs of the parallel processing outputs
  comb <- function(x, ...) {
    # input
    # --- series of dataframes generated by parallel processing
    # output
    # --- a big dataframe by vertically combing all dataframes
    lapply(seq_along(x), function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
    }

  # the number of cores that could be used
  cores <- min(detectCores(), dim(ydt)[2]) # minimum of possible cores and number of outcome variables
  # use all or some of them
  cl <- makeCluster(cores) # default: use all of the cores to speed up
  # register the parallel backend
  registerDoParallel(cl)

  # initialize two lists to store the tidy and glance results
  tidy_results <- list()
  glance_results <- list()

  # run the fit_model function in parallel for each dependent variable & combine the results in a list
  results <- foreach(ydt1 = ydt_list, .packages = packages, .combine='comb', .multicombine=T, .init=list(list(), list())) %dopar% {
      tryCatch({
        # merge the two data.tables
        dt <- cbind(xdt, ydt1$data) # not using merge by fID to save time
        # get yvar name
        yvar <- ydt1$name
        # model fit
        res <- fit_model('V1', formula, dt) # the column name of ydt1$data is always "V1"
        # tidy results
        tidy_results <- res$tidy
        tidy_results$Yvar <- yvar # New column of Yvar to be added
        # glance results
        glance_results <- res$glance
        glance_results$Yvar <- yvar # New column of Yvar to be added

      # return for each Y
      list(tidy_results, glance_results)
      },
      error = function(e) {
        # Log the error
        cat("Error happens in processing", ydt1$name, ":", conditionMessage(e), "\n")
      
        # Return NULL for errors, which will be filtered out later
        NULL
      })
    }

  # stop cluster
  stopCluster(cl)

  # list to dataframe of outputs
  TIDY   <-  do.call(rbind, results[[1]]) # statistical outputs (coef., t-value, p-value, etc.)
  GLANCE <-  do.call(rbind, results[[2]]) # model estimations

  # return
  return(list(TIDY = TIDY, GLANCE = GLANCE))
}

# (2.3) function to save broom TIDY results into csv files
save_broom_parallel <- function(TIDY, GLANCE, outdir, model_name){
  # input
  # --- TIDY, a data table of statistical outputs including statistics & p values
  # --- GLANCE, a data table of model estimations
  # --- outdir, the directory for storing all temporal results
  # --- model_name, model name, e.g., 'model_01'
  # output
  # --- a new folder "TIDY" under outdir, and contains
  #            subcolders corresponding to TIDY columns (e.g., statistic, p.value), and each subfolder contains
  #            subfolders corresponding to TIDY$term (e.g., GROUP, AGE, SEX, except for "Intercept"), and each subfolder contains
  #            csv file (share filename with yfile) of TIDY for the given column (e.g., "p.value") and given term (e.g., "GROUP")
  # --- a new folder "GLANCE" under outdir, and contains
  #            subfolder corresponding to GLANCE columns (e.g., AIC, BIC), and each subfolder contains
  #            csv file (share filename with yfile) of GLANCE for the given column (e.g., "AIC")

  # prnt some info
  print("Modelling completed! Now saving results ...")

  # TIDY terms excluding "(Intercept)"
  TIDY_terms <- setdiff(unique(TIDY$term), "(Intercept)")

  # TIDY columns excluding "term" and "Yvar"
  TIDY_cols <- setdiff(colnames(TIDY), c("effect","group","term","Yvar"))
  
  # GLANCE columns excluding "term" and "Yvar"
  GLANCE_cols <- setdiff(colnames(GLANCE), c("Yvar"))

  # combinations of terms & cols
  TIDY_term_cols   <- expand.grid("TIDY",  TIDY_terms, TIDY_cols)
  GLANCE_term_cols <- expand.grid("GLANCE",        "", GLANCE_cols)
  term_cols <- rbind(TIDY_term_cols, GLANCE_term_cols)

  # a function to split and save data
  save_data <- function(term_col) {
    # data of interest
    TIDY_GLANCE <- as.character(term_col[1][1,1]) # TIDY or GLANCE
    term1       <- as.character(term_col[2][1,1]) # term of interest, e.g., "GROUP"
    col         <- as.character(term_col[3][1,1]) # column of interest, e.g., "p.value"

    if (TIDY_GLANCE == "TIDY"){
      # for TIDY data table
      dt1 <- TIDY[term == term1, c('Yvar',col), with=FALSE]
      # dt1 <- TIDY[term == term1, list(Yvar, get(col))]
    } else {
      # for GLANCE data table
      dt1 <- GLANCE[,            c('Yvar', col), with=FALSE]
      # dt1 <- GLANCE[, list(Yvar, get(col))]
    }

    # make directory & save into csv files
    term1 <- gsub(":", "..", term1) # change ":" into ".." to avoid problems in naming folders
    dir.create( file.path(outdir, TIDY_GLANCE, col, term1), recursive = TRUE, showWarning = FALSE)
    fwrite(dt1, file.path(outdir, TIDY_GLANCE, col, term1, paste0(model_name,'.csv')))
  }

  # packages for parallel processing
  packages <- c("data.table")

  # Use parallel processing to speed up
  num_cores <- min(detectCores(), dim(term_cols)[1]) # minimum number of cores to save resources
  cl <- makeCluster(num_cores)
  # register the parallel backend
  registerDoParallel(cl)
  foreach(i = 1:dim(term_cols)[1], .packages = packages) %dopar% {save_data <- save_data(term_cols[i,]) }

  # parLapply(cl, split(term_cols, seq(nrow(term_cols))), save_data)
  stopCluster(cl)

  # end info
  cat('TIDY & GLANCE saved for',model_name,'\n')
}

# (3) main function to fit model and save broom style outputs
parallel_model <- function(xfile, yfile, out_dir, model_name, formula, fit_model_parallel, save_broom_parallel) {
  # arguments
  # --- xfile, fullpath to the csv file of independent variables (row = observation, column = variable)
  # --- yfile, fullpath to the csv file of depedent variables (row = observation, column = variable)
  #            !!! xfile & yfile MUST be matched by rows (i.e., each row represents the info of the same observation)
  # --- out_dir, path to the folder for saving outputs
  # --- model_name, text string of model name, e.g., 'model_01'
  # --- formula, text string of model formula, e.g., "lmer(Yvar ~ GROUP + AGE + SEX + (1|SITE))", or "lm(Yvar ~ GROUP + AGE + SEX)"
  # --- fit_model_parallel, the fit_model_parallel function defiend beforehand
  # --- save_broom_parallel, the save_broom_parallel function defined beforehand
  # output
  # --- a TIDY folder of statistical outputs per column (e.g., estimate, statistic, p.value) and per term (e.g., GROUP, SEX, and AGe, except for (Intercept))
  # --- a GLANCE folder of model estimation per column (e.g., nob, AIC, BIC)

  # output directory (same name as the yfile, just without file extension)
  outdir <- out_dir

  # read independent variables (Xs)
  xdt <- fread(xfile)

  # Extract variable names from the formula
  vars <- strsplit(formula, "[~+|()]")[[1]]
  vars <- gsub(" ", "", vars)  # remove spaces

  # Split the vector elements based on "*" and replace the original elements
  # for interactions such as "GROUP * AGE"
  vars <- unlist(lapply(vars, function(x) strsplit(x, "\\*")[[1]]))
 
  # column names that appear in both xdt and formula (add 'fID')
  xdt_cols <- c('fID',unlist(colnames(xdt)[colnames(xdt) %in% vars]))

  # clean xdt by keeping columns that appear in the formula (& fID)
  xdt <- xdt[,..xdt_cols]
  cols_xdt <- names(xdt)

  # read dependent variables (Ys)
  ydt <- fread(yfile, header=TRUE)
  cols_ydt <- names(ydt)

  # Merge xdt and ydt
  dt_merged <- merge(xdt, ydt, by = "fID", all = FALSE)

  # Update xdt & ydt
  xdt <- dt_merged[,..cols_xdt]
  ydt <- dt_merged[,..cols_ydt]

  # Drop fID in ydt
  ydt <- ydt[, !c("fID")]

  # function to check if a dataframe column is constant, full of NA, full of NaN, full of empty entries, full of the same value (e.g., constant without considering NA or NaN), or the number of rows that containing numeric values is no more than 5 
  count_numeric <- function(x) {sum(!is.na(x) & !is.nan(x) & is.numeric(x))} # function to get the number of rows that containing numeric values (not na or nan)
  is_bad_column <- function(col) {all(is.na(col)) || all(is.nan(col)) || all(col == "") || length(unique(col[!is.na(col) & !is.nan(col)])) == 1 || sum(sapply(col, count_numeric)) <= 5}
  # V27019

  # get the names of the bad columns in ydt that are constant, or full of NaNs, or full of NAs, or full of empty entries
  are_bad_columns <- sapply(ydt, is_bad_column)
  bad_columns <- colnames(ydt)[are_bad_columns]

  # model fitting & save outputs only when not all outcome variables are constant, NAs, NaNs, or empty entries
  if (length(bad_columns) < length(colnames(ydt))){
    # remove the bad columns (if any) from ydt
    if (length(bad_columns) > 0){ydt[, (bad_columns) := NULL]}

    # fit model parallely
    output <- fit_model_parallel(xdt, ydt, formula, fit_model)

    # save TIDY & GLANCE parallely
    save_broom_parallel(output$TIDY, output$GLANCE, outdir, model_name)
  }
}

# (4) run the main function based on terminal command
parallel_model(xfile, yfile, out_dir, model_name, formula, fit_model_parallel, save_broom_parallel)